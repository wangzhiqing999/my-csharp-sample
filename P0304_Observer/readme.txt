观察者模式是对象的行为模式，
又叫做发布-订阅(Publish/Subscribe)模式，
模型-视图(Model/View)模式，
源-监听器(Source/Listener)模式或从属者(Dependents)模式。


 
动机（motivation）
 
在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系”
――一个对象(目标对象)的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。
如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。
 
使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。


 
意图(Intent)
 
定义对象间的一种一对多的依赖关系，一便当一二对象的状态发生变化时，所有依赖于它的对象都得到通知并自动更新。
 
观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，
这个主题对象在状态发生变化时，会通知所有观察者对象，使它们自动更新自己。





在观察者模式里有如下的角色：

. 抽象主题（Subject）角色：
    主题角色把所有的观察者对象的引用保存在一个列表里；
	每个主题都可以有任何数量的观察者。
	主题提供一个接口可以加上或撤销观察者对象；主题角色又叫做抽象被观察者(Observable)角色； 
    抽象主题角色，有时又叫做抽象被观察者角色，可以用一个抽象类或者一个接口实现；在具体的情况下也不排除使用具体类实现。  


. 抽象观察者（Observer）角色：为所有的具体观察者定义一个接口，在得到通知时更新自己； 
    抽象观察者角色，可以用一个抽象类或者一个接口实现；在具体的情况下也不排除使用具体类实现。  


. 具体主题（ConcreteSubject）角色：
    保存对具体观察者对象有用的内部状态；在这种内部状态改变时给其观察者发出一个通知；
    具体主题角色又叫作具体被观察者角色；
    具体主题角色，通常用一个具体子类实现。  


．具体观察者（ConcreteObserver）角色：
    保存一个指向具体主题对象的引用；和一个与主题的状态相符的状态。
	具体观察者角色实现抽象观察者角色所要求的更新自己的接口，以便使本身的状态与主题的状态自恰。 
    具体观察者角色，通常用一个具体子类实现。



观察者模式的应用场景：
1、  对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。
2、  对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。


观察者模式的优点：
1、  Subject和Observer之间是松偶合的，分别可以各自独立改变。
2、  Subject在发送广播通知的时候，无须指定具体的Observer，Observer可以自己决定是否要订阅Subject的通知。
3、  遵守大部分GRASP原则和常用设计原则，高内聚、低偶合。


观察者模式的缺陷：
1、  松偶合导致代码关系不明显，有时可能难以理解。(废话)
2、  如果一个Subject被大量Observer订阅的话，在广播通知的时候可能会有效率问题。（毕竟只是简单的遍历）


