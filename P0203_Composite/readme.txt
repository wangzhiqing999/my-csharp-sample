本项目是“合成模式”模式的 例子代码


合成模式由以下部分组成：

1、抽象构件（Component）角色
这是一个抽象角色，它给参与组合的对象规定一个接口。这个角色给出共有接口及其默认行为。 


2、树叶构件（Leaf）角色
代表参加组合的树叶对象。一个树叶对象没有下级子对象。 


3、树枝构件（Composite）角色
代表参加组合的有子对象的对象，并给出树枝构件对象的行为。



可以看出，Composite类型的对象可以包含其它Component类型的对象。
换而言之，Composite类型对象可以含有其它的树枝（Composite）类型或树叶（Leaf）类型的对象。


合成模式的实现根据所实现接口的区别分为两种形式，
分别称为安全模式和透明模式。
合成模式可以不提供父对象的管理方法，
但合成模式必须在合适的地方提供子对象的管理方法（诸如：add、remove、getChild等）。



透明方式
作为第一种选择，在Component里面声明所有的用来管理子类对象的方法，
包括add（）、remove（），以及getChild（）方法。
这样做的好处是所有的构件类都有相同的接口。
在客户端看来，树叶类对象与合成类对象的区别起码在接口层次上消失了，
客户端可以同等同的对待所有的对象。这就是透明形式的合成模式。

这个选择的缺点是不够安全，因为树叶类对象和合成类对象在本质上是有区别的。
树叶类对象不可能有下一个层次的对象，因此add（）、remove（）以及getChild（）方法没有意义，
是在编译时期不会出错，而只会在运行时期才会出错。



安全方式
第二种选择是在Composite类里面声明所有的用来管理子类对象的方法。
这样的做法是安全的做法，因为树叶类型的对象根本就没有管理子类对象的方法，
因此，如果客户端对树叶类对象使用这些方法时，程序会在编译时期出错。

这个选择的缺点是不够透明，因为树叶类和合成类将具有不同的接口。


这两个形式各有优缺点，需要根据软件的具体情况做出取舍决定。




===============================================================================

安全式的合成模式由以下部分组成：

1、抽象构件(Component)角色
这是一个抽象角色，它给参加组合的对象定义出公共的接口及其默认行为，可以用来管理所有的子对象。
在安全式的合成模式里，构件角色并不是定义出管理子对象的方法，这一定义由树枝构件对象给出。 


2、树叶构件（Leaf）角色
树叶对象是没有下级子对象的对象，定义出参加组合的原始对象的行为。 


3、树枝构件（Composite）角色
代表参加组合的有下级子对象的对象。树枝对象给出所有的管理子对象的方法，如add（）、remove（）、getChild（）等。


===============================================================================

与安全式的合成模式不同的是，透明式的合成模式要求所有的具体构件类，不论树枝构件还是树叶构件，均符合一个固定的接口。

透明式的合成模式结构由以下部分组成：


1、抽象构件（Component）角色
这是一个抽象角色，它给参加组合的对象规定一个接口，规范共有的接口及默认行为。 


2、树叶构件（Leaf）角色
代表参加组合的树叶对象，定义出参加组合的原始对象的行为。
树叶类会给出add（）、remove（）以及getChild（）之类的用来管理子类对对象的方法的平庸实现。 


3、树枝构件（Composite）角色：代表参加组合的有子对象的对象，定义出这样的对象的行为。



===============================================================================

使用合成模式时考虑的几个问题
明显的给出父对象的引用。在子对象里面给出父对象的引用，可以很容易的遍历所有父对象。有了这个引用，可以方便的应用责任链模式。 
在通常的系统里，可以使用享元模式实现构件的共享，但是由于合成模式的对象经常要有对父对象的引用，因此共享不容易实现。 
有时候系统需要遍历一个树枝结构的子构件很多次，这时候可以考虑把遍历子构件的结果暂时存储在父构件里面作为缓存。 
关于使用什么数据类型来存储子对象的问题，在示意性的代码中使用了ArrayList，在实际系统中可以使用其它聚集或数组等。 
客户端尽量不要直接调用树叶类中的方法，而是借助其父类（Component）的多态性完成调用，这样可以增加代码的复用性。


