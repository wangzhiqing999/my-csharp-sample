策略模式就是定义了多种算法，而让不同算法之间的切换不会影响到客户端。 

策略模式主要涉及3个组成部分 
（1）环境对象(Context)：该类中实现了对抽象策略中定义的接口或者抽象类的引用。 
（2）抽象策略对象(Strategy)：它可由接口或抽象类来实现。 
（3）具体策略对象(ConcreteStrategy)：它封装了实现同不功能的不同算法。 



在下面的情况下应当考虑使用策略模式：

1. 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。

2. 一个系统需要动态地在几种算法中选择一种。
    那么这些算法可以包装到一个个的具体算法类里面，而这些具体算法类都是一个抽象算法类的子类。
	换言之，这些具体算法类均有统一的接口，由于多态性原则，客户端可以选择使用任何一个具体算法类，并只持有一个数据类型是抽象算法类的对象。
	
3. 一个系统的算法使用的数据不可以让客户端知道。
    策略模式可以避免让客户端涉及到不必要接触到的复杂的和只与算法有关的数据。

4. 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。
    此时，使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句，并体现面向对象设计的概念。




策略模式的优点有：
1. 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。
    恰当使用继承可以把公共的代码移到父类里面，从而避免重复的代码。

2. 策略模式提供了可以替换继承关系的办法。继承可以处理多种算法或行为。
    如果不是用策略模式，那么使用算法或行为的环境类就可能会有一些子类，每一个子类提供一个不同的算法或行为。
	但是，这样一来算法或行为的使用者就和算法或行为本身混在一起。
	决定使用哪一种算法或采取哪一种行为的逻辑就和算法或行为的逻辑混合在一起，从而不可能再独立演化。
	继承使得动态改变算法或行为变得不可能。

3. 使用策略模式可以避免使用多重条件转移语句。多重转移语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重转移语句里面，比使用继承的办法还要原始和落后。



策略模式的缺点有：
1. 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。
    这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。
	换言之，策略模式只适用于客户端知道所有的算法或行为的情况。

2. 策略模式造成很多的策略类。
    有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。
	换言之，可以使用享元模式来减少对象的数量。



其它
策略模式与很多其它的模式都有着广泛的联系。Strategy很容易和Bridge模式相混淆。虽然它们结构很相似，但它们却是为解决不同的问题而设计的。 Strategy模式注重于算法的封装，而Bridge模式注重于分离抽象和实现，为一个抽象体系提供不同的实现。Bridge模式与Strategy模式都很好的体现了"Favor composite over inheritance"的观点。


